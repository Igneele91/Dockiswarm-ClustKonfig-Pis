

## 5.2. Installation des Nginx Proxy Managers

## Die Installation erfolgt über ein Docker Compose-File. Ein Beispiel für ein Docker Swarmkompatibles File sieht folgendermassen aus:

version: '3.7'
services:
  app:
    image: 'jc21/nginx-proxy-manager:latest'
    ports:
      - '80:80'
      - '81:81'
      - '443:443'
    volumes:
      - ./config.json:/app/config/production.json
      - ./data:/data
      - ./letsencrypt:/etc/letsencrypt
    environment:
      DB_MYSQL_HOST: "db"
      DB_MYSQL_PORT: 3306
      DB_MYSQL_USER: "npm"
      DB_MYSQL_PASSWORD: "npm"
      DB_MYSQL_NAME: "npm"
    depends_on:
      - db
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == worker
          
  db:
    image: 'jc21/mariadb-aria:latest'
    environment:
      MYSQL_ROOT_PASSWORD: 'npm'
      MYSQL_DATABASE: 'npm'
      MYSQL_USER: 'npm'
      MYSQL_PASSWORD: 'npm'
    volumes:
      - ./data/mysql:/var/lib/mysql
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == worker



## Version 2 ## Nur Datenbank Maria DB

{
  "database": 
  {
    "engine": "mysql",
    "host": "db",
    "name": "npm",
    "user": "npm",
    "password": "npm",
    "port": 3306
  }
}





## 5.9. Anleitung für das Integrieren von Nginx Proxy Manager 
## Teil 1: Erstellen des Docker-Stacks für den Nginx Proxy Manager 
## 5. Im Feld "Web editor" fügen Sie den folgenden Code ein:

version: '3.7'    ##  eigentlich Version 3.8 
services:
  app:
    image: 'jc21/nginx-proxy-manager:latest'
    restart: unless-stopped
    ports:
      # These ports are in format <host-port>:<container-port>
      - '80:80' # Public HTTP Port
      - '443:443' # Public HTTPS Port
      - '81:81' # Admin Web Port
      # Add any other Stream port you want to expose
      # - '21:21' # FTP
    environment:
      # Mysql/Maria connection parameters:
      DB_MYSQL_HOST: "db"
      DB_MYSQL_PORT: 3306
      DB_MYSQL_USER: "npm"
      DB_MYSQL_PASSWORD: "npm"
      DB_MYSQL_NAME: "npm"
      # Uncomment this if IPv6 is not enabled on your host
      # DISABLE_IPV6: 'true'
    volumes:
      - ./data:/data
      - ./letsencrypt:/etc/letsencrypt
    depends_on:
      - db

  db:
    image: 'jc21/mariadb-aria:latest'
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: 'npm'
      MYSQL_DATABASE: 'npm'
      MYSQL_USER: 'npm'
      MYSQL_PASSWORD: 'npm'
    volumes:
      - ./mysql:/var/lib/mysql



## Teil 2: Erstellen der Konfigurationsdatei für den Nginx Proxy Manager       

# 1. Navigieren Sie zurück zum Dashboard und klicken Sie auf "Containers" auf der linken Seite.
# 2. Suchen Sie den Container, der den Nginx Proxy Manager ausführt, und klicken Sie auf dessen Namen.
# 3. Auf der Container-Seite klicken Sie oben auf der Seite auf "Console".
# 4. Klicken Sie auf "Connect". Sie sollten nun eine Befehlszeilenkonsole sehen, die direkt im Nginx Proxy Manager Container läuft.
# 5. Geben Sie den folgenden Befehl ein, um eine Konfigurationsdatei zu erstellen:


  nano config.json 




## 6. Fügen Sie den folgenden Inhalt in die Datei ein:

{
  "database": 
  {
    "engine": "mysql",
    "host": "db",
    "name": "npm",
    "user": "npm",
    "password": "npm",
    "port": 3306
  }
}


## Teil 3: Meine Konfiguration angepasst auf mein Cluster

## ch habe meine Konfiguration entsprechend meinem Cluster angepasst. Hier ist meine
## gewählte Konfiguration:


version: '3.9'
services:
  app:
    image: 'jc21/nginx-proxy-manager:latest'
    ports:
      - '80:80'
      - '81:81'
      - '443:443'
    volumes:
      - ./config.json:/app/config/production.json
      - ./data:/data
      - ./letsencrypt:/etc/letsencrypt
    environment:
      DB_MYSQL_HOST: "db"
      DB_MYSQL_PORT: 3306
      DB_MYSQL_USER: "npm"
      DB_MYSQL_PASSWORD: "npm"
      DB_MYSQL_NAME: "npm"
    depends_on:
      - db
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
    # In diesem Beispiel wird der Neustart des 'app' Service versucht, wenn ein Fehler auftritt. 
    # Wenn ein Manager-Knoten ausfällt, sollte der Service automatisch auf einem anderen Manager-Knoten neu gestartet werden.

  db:
    image: 'jc21/mariadb-aria:latest'
    environment:
      MYSQL_ROOT_PASSWORD: 'npm'
      MYSQL_DATABASE: 'npm'
      MYSQL_USER: 'npm'
      MYSQL_PASSWORD: 'npm'
    volumes:
      - ./data/mysql:/var/lib/mysql
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
    # Das Gleiche gilt für den 'db' Service. 
    # Beachten Sie jedoch, dass dies nur eine grundlegende Ausfallsicherheit bietet. 
    # Je nach den spezifischen Anforderungen und Umständen Ihrer Anwendung und Infrastruktur könnten 
    # zusätzliche Schritte und Überlegungen erforderlich sein, um eine vollständige Ausfallsicherheit 
    # und Fehlertoleranz zu gewährleisten. 
    # Es ist immer eine gute Idee, eine gründliche Planung und Tests durchzuführen, 
    # um sicherzustellen, dass Ihre Ausfallsicherheitsstrategie in einer realen Umgebung effektiv funktioniert.






##################################################################################


